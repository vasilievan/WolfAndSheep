# Волк и овцы
## Правила игры
“Волк и овцы” – шашечная игра для двух игроков.
Изначально овечка (белая фигура из шашек) стоит на случайной клетке в конце доски, волки же стоят линией на противоположном конце доски. Первый ход делает овечка. Далее ходит один из волков и цикл повторяется.
Овечка может походить на любую соседнюю темную клетку доски. Волк же ходит только вперёд.
Игра заканчивается, либо когда у овечки нет больше возможных ходов (волки “зажали” её в угол), либо когда овечка дошла до противоположного конца доски. 

Доказано, что при корректной игре волки всегда побеждают.

## Эвристика ИИ
В ходе реализации программы было написано 2 искусственных интеллекта: ИИ для волков, ИИ для овечки.

Существует распространённое мнение, каким должен быть хороший ИИ. “Главная задача ИИ – не выиграть у игрока, а красиво ему отдаться.”

Для данной игры существует решение на основе алгоритма Minimax.  Оно было реализовано мной в альфа-версии программы. В нем используется рекурсивный алгоритм полного перебора возможных комбинаций на 6 ходов вперёд от данной позиции. Для каждой данной комбинации рассчитываются стоимости по графу, запускается поиск в ширину от позиции овечки. Соседние с овечкой клетки имеют вес 1, соседние с соседними – 2 и т.д. Все возможные веса суммируются. Ход с минимальным весом для овечки является выигрышным, с максимальным – проигрышным (выигрышным при игре за волков). К сожалению, оно не показалось мне удовлетворительным по ряду причин:

1.	Рассчитаю, сколько всего перебирается комбинаций. Допустим, сейчас ИИ ход за овечку. Количество комбинаций на уровне с глубиной 6: 4*8*4*8*4*8 = 32 768. В расчётах представлен худший случай, когда овечка может ходить на все возможные клетки, как и волки. Время расчёта по моему субъективному мнению, оказалось слишком велико, на моей машине (SoC: Qualcomm Snapdragon 665) порядка 45 секунд;

2.	Ситуация 100% выигрыша при ИИ за волков меня также не устраивает, т.к. у пользователя исчезает смысл играть за овечку вовсе.

Поэтому была разработана собственная эвристика с опорой на научную статью. 

Рассмотрю эвристику при игре за волков.

Введу понятие “точки невозврата” – позиция для овечки, когда она стоит позади волка в непосредственной близости и может ходить. Это состояние, когда цепь волков разорвана. У нее есть характеристика, стоимость – количество ходов овечки, чтобы ее достичь. Тактика игры за волков – не допускать возникновение точек невозврата, а если они возникают, максимизировать стоимость данной точки.
Однако могут возникнуть ситуации, когда при ходе каких-либо двух и более волков появляются точки невозврата с равными стоимостями. В таких случаях эвристика не работает и алгоритм обращается к базе ходов, представляющей собой множество состояний, где позиции волков представлены векторами, а также имеется информация о том, какой ход нужно сделать конкретному волку при данном ходе овцы.
Отмечу, что эвристика покрывает большинство обычных случаев, в базе 20 записей, при этом волки выигрывают приблизительно в 80% случаев, что я считаю удовлетворительным результатом, т.к. игроку интересно играть за овечку (был проведен неформальный опрос среди студентов). Скорость принятия решений велика.

Рассмотрю эвристику при игре за овцу.

Для овцы рассчитываются стоимости по графу и одновременно находится возможный ход, ведущий к одной из победных клеток (разрыв в цепи волков). Если такой ход существует, овечка ходит туда. Иначе – на позицию с наименьшей стоимостью. Преимущество алгоритма в том, что овечка не перебирает 32 768 комбинаций, ограничиваясь 4 (глубина рекурсии 1). При этом опять-таки при игре за волков можно с лёгкостью допустить ошибку, ведущую к победе овечки. Неформальный опрос подтвердил интерес игроков к этому режиму также.

## Описание программы
В приложении реализована архитектура MVVP. Написано на языке Kotlin (v. 1.4.10). Используется открытый игровой движок libGDX.  Сборщик проекта – Gradle v. 29.0.3. Разделено на 2 модуля – android и core согласно архитектуре игрового движка. Это связано с тем, что libGDX – кроссплатформенный движок (разработка под iOS, html, Desktop и др.).

### Модуль android
Структура аналогична стандартному android-приложению. В папке java находится единственный пакет aleksey.vasiliev.wolfandsheep, в котором находится единственный класс-“запускалка” – AndroidLauncher (также это точка входа в приложение). Никакой игровой логики в данном классе нет, он связывает стандартное окно в OS Android – Activity с модулем core, где и находится вся игровая логика.
В папке assets находятся используемые игровые ресурсы: изображения и шрифты.

### Модуль core
Содержит папку java, в которой находятся два пакета –aleksey.vasiliev.wolfandsheep и tests. В первом пакете находится вся игровая логика, а во втором – тесты к логике приложения.

### Пакет aleksey.vasiliev.wolfandsheep
#### Подпакет screens
Объединяет классы, представляющие собой экраны приложения.

##### Класс Beginning
Класс, представляющий собой окно, которое видит пользователь при запуске или при новой игре. В этом окне пользователь выбирает, за кого будет играть – овечка (нажимает на белую окружность) или волки (нажимает на чёрную окружность). В классе реализован слушатель событий (inputProcessor), а также методы отрисовки, свойственные суперклассу Screen.

##### Класс MainMenu
Класс, представляющий собой окно, которое видит пользователь непосредственно при игре. В нем происходит отрисовка игровой доски, волков, а также овечки. В классе реализован слушатель событий (inputProcessor) для работы логики и ИИ, а также методы отрисовки, свойственные суперклассу Screen.

##### Класс TheEnd
Класс, представляющий собой окно, которое видит пользователь при завершении игры. В нем представлен результат партии: “You win!” – если пользователь победил и “You lose!”, если проиграл. В классе реализован слушатель событий (inputProcessor), по нажатию открывается экран Beginning, а также методы отрисовки, свойственные суперклассу Screen.

#### Подпакет helpers
Содержит вспомогательные классы для обеспечения игровой логики.

##### Класс ResourceContainer
Паттерн singleton. Содержит константы, а также объекты, используемые как глобальные. Запускается первым из Activity (AndroidLauncher). В методе create создается граф и шашечные фигуры, открывается окно Beginning.

##### Класс Graph
Граф, необходимый для реализации логики по перемещению фигур, ходов искусственного интеллекта, представленный списком смежностей. Рёбра не хранятся, соседи вершины формируются динамически.
Также в нём реализованы методы, начинающиеся со слова options, необходимые для работы ИИ (формирование возможных ходов волка или овечки) и подсказок пользователю по возможным ходам.

##### Вложенный класс Node
Вершина графа.
Внутри методы для получения соседних вершин с данной. Названы по аналогии со сторонами света, если бы сверху доски был север, снизу юг, справа - восток, слева - запад.

##### Класс Configuration
Содержит возможные конфигурации игры, которая определяется по выбору игрока в окне Beginning.

##### Класс Board
Класс, описывающий шахматную доску. Является связующим звеном между логикой приложения и отрисовкой.
В нем хранится список волков, овца, ИИ. Обеспечено взаимодействие пользователя и ИИ, осуществляется обработка, какая фигура выбрана пользователем, высвечиваются подсказки по возможным ходам для выбранной фигуры, отрисовывается шахматная доска, а также все фигуры.

#### Подпакет chesspieces
Содержит классы, описывающие шашечные фигуры, овечку и волка.

##### Класс ChessPiece
Абстрактный класс, описывающий шахматные фигуры. У фигуры есть текущая вершина графа (ее положение на доске), текстура, выбрана она или нет, а также методы по отрисовке и перемещению. Т.е. это более низкий уровень абстракции, чем, например, вершина графа.

##### Класс Wolf
Описывает волка как шахматную фигуру, наследник класса ChessPiece.

##### Класс Sheep
Описывает овечку как шахматную фигуру, наследник класса ChessPiece.

##### Подпакет ais
Содержит классы, описывающие искусственный интеллект.

##### Класс AI
Данный интерфейс имеет лишь 1 метод (move), необходимый для осуществления хода ИИ, и объединяет оба искусственных интеллекта, при игре за волков и за овечку.
 
##### Класс WolfAI
Данный класс является реализацией искусственного интеллекта при игре пользователя за овечку.
Проверяю все возможные ходы волков на 1 ход вперёд. Используя поиск в ширину, нахожу точки невозврата. Выбираю ход, при котором овечке дольше всего бежать до точки невозврата (максимальная глубина рекурсии при BFS). И хожу так.
Очевидно, есть исключения, но их всего 20. Обрабатываю отдельно.
Сложность алгоритма - O(v + e), где v - к-во вершин графа, e - к-во рёбер (соседей данной вершины).
Память - O(v), v - к-во вершин графа.
Также в классе содержатся методы для определения, победил игрок или ИИ.

##### Класс Case
Класс с данными для обработки исключений. Представлю позицию волков и овечки как пятимерный вектор, состоящий для удобства восприятия и соблюдения принципов ООП из двух разных объектов.
Дополнительная информация в классе представляет собой порядковый номер волка, который должен ходить, а также выигрышный ход.

##### Класс SheepAI
Данный класс является реализацией искусственного интеллекта при игре пользователя за волков.
Овечка всегда ходит первой. Использование init позволяет штатно обрабатывать оба искусственных интеллекта.
Используется модификация алгоритма из класса WolfAI. BFS (поиск в ширину) теперь нужен для расстановки весов нод по степени удаления от овечки. Результат работы функции countCost - сумма данных весов, а также возможные варианты по достижению конца доски с соответствующими весами. Если конец доски достижим, овечка стремится туда. Иначе выбирается минимальная стоимость, означающая близость овечки к концу доски и наличие множества свободных ходов.
Сложность алгоритма - O(v + e), где v - к-во вершин графа, e - к-во рёбер (соседей данной вершины).
Память - O(v), v - к-во вершин графа.
Также в классе содержатся методы для определения, победил игрок или ИИ.

## Тестирование приложения
### Пакет tests
Состоит из классов-оберток (имя заканчивается на Wrapper), не отличающихся от одноименных из core ничем, кроме отсутствия связи с графическими ресурсами, и класса Tests, где непосредственно находятся тесты к графу и искусственным интеллектам. Для тестирования была использована библиотека kotlin.tests.*. Тесты показали корректную работу логики приложения.
Графический интерфейс был протестирован архаичным образом – на эмуляторе и на устройстве.
